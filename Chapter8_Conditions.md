---
Title: "Chapter 8"
Author: "Batuhan T. Bozkurt"
Date: "2022-11-6"
---

# Quiz
1.  What are the three most important types of condition?
    
2.  What function do you use to ignore errors in block of code?
    
3.  What’s the main difference between [tryCatch()](https://rdrr.io/r/base/conditions.html) and [withCallingHandlers()](https://rdrr.io/r/base/conditions.html)?
    
4.  Why might you want to create a custom error object?
# Exercises
## 8.2.4
1. Write a wrapper around file.remove() that throws an error if the file to be deleted does not exist.
```r
file.remove_b <- function(path)
{
	if(file.exists(path)==FALSE)
		stop("The file does not exist")
	else
		file.remove(path)
}
```
2. What does the appendLF argument to message() do? How is it related to cat()?
	If appendLF is TRUE, calling message multiple times in a function has will have each "message" on a separate line. appendLF = FALSE forms a stiched string of all mesages. Using cat() with strings will do the same (in fact, message() code has cat() in it)

## 8.4.5
1. What extra information does the condition generated by abort() contain compared to the condition generated by stop() i.e. what’s the difference between these two objects? Read the help for ?abort to learn more.
	Abort is capable of outputting more info, while stop just ends the function and prints a message: 
		1. `call` to inform which function created the error
		2. `class` condition that can be caught or handeled selectively
		3. Metadata, can be followed with traceback

2. Prediction:
	1.  Stop will print "error"
	2. With 10, the "code" part might print 10, then NULL
	3. Warning will let the code run, and raise a warning of "warning"
	4. ?
3. ? I don't get the 3rd line ("b")
4. Makes sure condition is a character, creates a list of all conditions of a class that you supply to the function, checks if your condition is a member of that class.
   ```r
   function (expr, classes = "condition") 
{
  stopifnot(is_character(classes))
  handlers <- rep_named(classes, list(identity))
  eval_bare(rlang::expr(tryCatch(!!!handlers, {
    force(expr)
    return(NULL)
  })))
}

```

5. ? Why would we even need to do this?
# Notes